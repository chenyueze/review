# 网络编程

## `socket()`

1. `int socket(int domian, int type, int protocol)`
2. `domain:`
   1. `AF_INET, AF_INET6, AF_LOCAL, AF_ROUTE`
3. `type:`
   1. `SOCK_STREAM, SOCK_DGRAM, SOCK_PACKET, SOCK_SEQPACKET`
4. `protocol:`
   1. `IPPOTO_TCP, IPPOTO_UDP, IPPOTO_STCP, IPPOTO_TICP`

## `listen()`

1. `int listen(int sockfd, int backlog)`
2. `backlog`被动等待允许的链接数目

## `accept()`

1. `int accept(int sockfd, struct scockaddr *addr, socklen_t *addrlen)`
2. `sockfd 必须经由 listen 和 bind 处理过`
3. `有链接进来时会返回一个新的 scokfd 代码用于连接，原来的依旧等待`
4. `连线成功时，系统会把客户端的地址存在 addr 中 `

## `connect`

1. ``int connect(int sockfd, struct scockaddr *addr, socklen_t *addrlen)``
2. 调用`addr`中存的地址连接

## `close`

## `send()`

## `recv()`

## `bind()`

1. `int bind(int sockfd, const struct sockaddr *addr, socketlen_t addrlen)`

2. `sockfd:`

   1. `socket的返回值`

3. `addr:`

   1. `指向数据结构 struct sockaddr 的指针，保存你的地址信息（端口，ip）`

   2. 相关结构体：

      1. ```
         struct sockaddr{
         	sa_family_t sin_family;
         	char sa_data[14];
         }
         
         struct sockaddr_in{
         	sa_family_t sin_family;
         	in_port_t sin_port;
         	struct in_addr sin_addr; //inet_ntoa(sin_addr)
         		//inet_aton(server_addr_string, &my_ sin_addr)
         }
         
         struct in_addr{
         	uint32_t s_addr; //inet_addr(192.168.0.1)
         }
         ```

   

4. `addrlen:`

   1. `sizeof(struct sockaddr)`

5. 返回值

   1. -1 为错误

# I/O 多路复用

## 问题：

### 1.多进程：

1. 进程数量
2. 代价太高
3. 受限于 cpu 核心数
4. 内存隔离
5. 进程间通信代价高

### 2.多线程

1. 受限于 cpu：影响响应能力

### 3.阻塞：

​		响应能力差

### 4.非阻塞：

​		循环

## I/O 多路复用

1. Select(Pselect)